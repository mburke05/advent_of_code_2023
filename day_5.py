# part 1
# 1. Read and parse the input file
# 1a. Split the input file into a dict, each value is a list of lists corresponding to the mappings
# 2. Write a subfunction that takes in a source value and looks up in a list to see a) if its in a given range and b) if not use the source value, and c) ensure it returns the proper destination range value
# 3. Write logic that takes in a seed input and traverses each dict with mappings until you arrive at a location output and store that in a list
# 4. Return the minimum value of that list


from typing import Union


def source_to_destination_check(source: int, mapping: list[int]) -> Union[int, None]:
    """
    Takes as an input a source value (integer) and a list of lists representing potential source/destination ranges.

    The mappings are a list of integers of the form [destination_value, source_value, source_range_length]

    For example: [50, 98, 2] accepts a seed value of 98 or 99 and for seed 98 the destination value would be 50, and for seed 99 the destination value would be 51

    As another example: [52, 50, 48] accepts a seed value of 50, 51, 52, 53, 54, 55, 56, 57 and for seed 50 the destination value would be 52, for seed 51 the destination value would be 53, etc
    """

    # first check if the value is in the range generated by the source value and source range length, e.g. if source is 98 and source range length is 2, check if its in 98-99
    if source in range(mapping[1], mapping[1] + mapping[2]):
        # we need the index that the number is in the range so we can add that to the destination value
        offset = source - mapping[1]
        return mapping[0] + offset

    # we didn't find a mapping, so return None
    return None


def find_destination_value(
    source: int,
    mappings: list[int],
) -> Union[int, None]:
    # we take a list of mappings and for each mapping we use source_to_destination_check to see if there's a valid mapping
    # if there isn't we'll return the source value

    for mapping in mappings:
        destination_val = source_to_destination_check(source, mapping)
        if destination_val is not None:
            return destination_val

    return source


def read_and_parse_input():
    with open("input.txt") as f:
        # seeds are in the first line, which will have a "seeds: " prefix followed by a list of integers which are our seeds
        seeds = [int(x.strip()) for x in f.readline().split(": ")[1].split(" ")]

        # next are seed-to-soil mappings, which will have a line with a "seed-to-soil map:" string, the next line begins the mappings until the next line is a blank line
        # we can use the blank line to denote the end of the mappings. this will occur a few times in the same format (ie. seed-to-soil map:, mappings, blank line, soil-to-fertilizer-map:, mappings, blank line, etc.)
        # so we can traverse the rest of the file with that in mind and, when we find a line that has a :, set that value (before the colon) as the key, and
        # the values are going to be a list of lists, where each list is a line which will be an array of integers

        mappings = {}

        for line in f:
            if ":" in line:
                key = line.split(":")[0].strip()
                mappings[key] = []
            elif line.strip() == "":
                continue
            else:
                mappings[key].append([int(x.strip()) for x in line.split(" ")])

        return seeds, mappings


seeds, mappings = read_and_parse_input()
locations = []
for seed in seeds:
    # we need to traverse mappings from the seed value until its final location value
    # the ordering is:
    # 1) seed,
    # 2) seed-to-soil,
    # 3) soil-to-fertilizer,
    # 4) fertilizer-to-water,
    # 5) water-to-light,
    # 6) light-to-temperature,
    # 7) temperature-to-humidity,
    # 8) humidity-to-location
    # so we will take as an input the seed value, and in sequence run it through a subfunction that will take its value and return the next value in the sequence

    ordered_mappings = [
        "seed-to-soil",
        "soil-to-fertilizer",
        "fertilizer-to-water",
        "water-to-light",
        "light-to-temperature",
        "temperature-to-humidity",
        "humidity-to-location",
    ]

    curr_source = seed
    for mapping in ordered_mappings:
        curr_source = find_destination_value(curr_source, mappings[mapping + " map"])
    locations.append(curr_source)

print(min(locations))
